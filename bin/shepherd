#!/usr/bin/env python
import os
import sys
import re
import json
import time
import fcntl
import base64
import signal
import httplib
import importlib


def http_client(method, resource, args=None):
    start_time = time.time()
    headers = {
        'X-SHEPHERD-APPID'   : os.environ.get('APPID'),
        'X-SHEPHERD-AUTHKEY' : os.environ.get('AUTHKEY')
    }

    request  = None
    status   = None
    reason   = None
    response = None

    try:
        request = json.dumps(args)

        conn = httplib.HTTPConnection(os.environ['API'])
        conn.request(method, resource, request, headers)

        handle   = conn.getresponse()
        status   = handle.status
        reason   = handle.reason
        response = handle.read()
    except Exception as e:
        status   = 500
        reason   = 'EXCEPTION'
        response = json.dumps(str(e))

    logger.log('API', ('method({0}) resource({1}) status({2}) reason({3}) ' +
                       'request({4}) response({5}) usec({6})').format(
                       method, resource, status, reason, len(request),
                       len(response), int((time.time()-start_time)*1000000)))

    return status, reason, json.loads(response)


class Logger(object):
    def __init__(self, thread, session=None):
        if not session:
            session = time.strftime('%y%m%d%H%M%S', time.gmtime())

        self.sequence = 0
        self.session  = "[%s %s %d" % (thread, session, os.getpid())

    def log(self, msgORtag, message=None):
        self.sequence += 1

        utc = time.time()

        if message:
            tag = msgORtag
            msg = message
        else:
            tag = 'LOG'
            msg = msgORtag
            
        index = msg.find('\n')
        if index > -1:
            tag = 'BLOB'
            msg = base64.b64encode(msg)

        os.write(3, '\n{0} {1} {2}.{3} {4}] : {5}'.format(
            self.session,
            self.sequence,
            time.strftime("%y%m%d.%H%M%S", time.gmtime(utc)),
            '%06d' % (int((utc - int(utc)) * 1000000)),
            tag,
            msg))

        return self.sequence

    def blob(self, msg):
        return log('BLOB', msg)


def worker(state, event):
    log(event['code'])

    workflow = state['workflow']
    input    = state['input']

    if 'init' == event['code']:
        control_info = dict(state='init', seq=0)
        continuation = None
    else:
        control_info = state['control_info']
        continuation = state['continuation']
        control_info['seq'] += 1

    current_state = control_info['state']

    try:
        result      = (None,)
        module      = importlib.import_module(workflow)
        module.log  = log

        if event['code'] in ['alarm', 'init', 'locked']:
            method_name = control_info['state']
        else:
            method_name = 'handler'

        method = getattr(module, method_name)
        if 'handler' == method_name:
            result = method(input, continuation, event)
        else:
            result = method(input, continuation)

        if len(result) < 2:
            raise Exception('invalid return value')
    except Exception as e:
        log('state transition. current({0}) return({1}) exception({2})'.format(
                current_state, result[0], str(e)))
        return dict(status=str(e))

    if 2 == len(result):
        log('state transition. finished. method({0}) return({1})'.format(
                current_state, result[0]))
        return dict(status=result[1])

    next_state = None
    if 'retry' != result[0]:
        next_state = module.workflow.get((method_name, result[0]))
        if next_state:
            control_info['state'] = next_state
    else:
            next_state = control_info['state']
            
    commit_dict = dict(status=result[1],
                       state=dict(workflow=workflow,
                                  input=input,
                                  control_info=control_info,
                                  continuation=result[2]))

    if 'lock' == result[0]:
        commit_dict['lock']   = result[3]

    if 'unlock' == result[0]:
        commit_dict['unlock'] = result[3]

    if 'message' == result[0]:
        commit_dict['message'] = result[3]

    if 'moveto' == result[0]:
        commit_dict['pool'] = result[3]

    if (next_state is not None) and ('lock' != result[0]):
        commit_dict['alarm'] = 0

    if  result[0] in ['sleep', 'alarm', 'retry']:
        commit_dict['alarm'] = result[3]

    log('state transition. method({0}) return({1}) next({2})'.format(
            method_name, result[0], next_state))
    return commit_dict


logger = Logger(sys.argv[1])


if 'launcher' == sys.argv[1]:
    os.umask(0077)
    logseq = int(time.strftime('%y%m%d%H',
                               time.gmtime((time.time()//(6*3600))*6*3600)))

    os.dup2(os.open('/dev/null', os.O_RDONLY), 0)
    os.dup2(os.open('out.%d' % (logseq), os.O_CREAT|os.O_WRONLY|os.O_APPEND), 1)
    os.dup2(os.open('err.%d' % (logseq), os.O_CREAT|os.O_WRONLY|os.O_APPEND), 2)
    os.dup2(os.open('log.%d' % (logseq), os.O_CREAT|os.O_WRONLY|os.O_APPEND), 3)

    try:
        os.dup2(os.open('lock', os.O_CREAT|os.O_RDONLY), 4)
        fcntl.flock(4, fcntl.LOCK_EX|fcntl.LOCK_NB)
    except:
        logger.log('could not acquire lock. launcher is already running')
        exit(0)

    for path in os.listdir('.'):
        match = re.search('(out|err|log)\.(\d{8})', path)
        if match:
            if int(match.group(2)) < (logseq-6):
                os.remove(path)
                logger.log('removed {0}'.format(path))

    os.environ['API'] = sys.argv[2]

    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    timeout = time.time() + 300
    while time.time() < timeout:
        time.sleep(1)

        status, reason, pending = http_client('GET', '/pending')
        if 200 != status:
            continue
        
        myip = pending['client_ip']
        if myip not in pending['allocation']:
            continue

        app_dict = dict()
        for uid, count in pending['allocation'][myip].iteritems():
            app_dict[uid] = dict(
                async_count=count,
                authkey=pending['applications'][uid]['authkey'],
                path=pending['applications'][uid]['path'])

        proc_count = dict()
        for d in [d for d in os.listdir('/proc') if d.isdigit()]:
            try:
                uid = os.stat('/proc/{0}'.format(d)).st_uid
            except OSError:
                pass

            proc_count.setdefault(uid, 0)
            proc_count[uid] += 1

        for uid, app in app_dict.iteritems():
            os.environ['AUTHKEY'] = app['authkey']
            os.environ['APPID']   = uid

            if not os.path.isdir(uid):
                os.mkdir(uid, 0700)
                os.chown(uid, int(uid), int(uid))

            count = 0
            for i in range(app['async_count'] - proc_count.get(int(uid), 0)):
                if 0 == os.fork():
                    os.close(4)

                    os.setsid()
                    os.setgid(int(uid))
                    os.setuid(int(uid))

                    os.chdir(uid)
                    signal.signal(signal.SIGCHLD, signal.SIG_DFL)

                    os.execv(app['path'], [app['path'], sys.argv[0], 'worker'])
                else:
                    count += 1
            logger.log('spawned count({0}) for uid({1})'.format(count, uid))

    time.sleep(1)
    os.system(' '.join(sys.argv) + '&')
elif 'worker' == sys.argv[1]:
    appdir = os.getcwd()
    logger = Logger('worker')

    try:
        import worker as worker_module
    except:
        worker_module = sys.modules['__main__']

    timeout = time.time() + 300
    while time.time() < timeout:
        os.umask(0077)
        os.chdir(appdir)

        status, reason, msg = http_client('POST', '/lockmessage', dict())
        if (200 != status) or ('NOT_FOUND' == msg):
            break

        worker_logger = Logger('worker-' + str(msg['workerid']), msg['session'])
        worker_module.log  = worker_logger.log

        event = dict(code=msg['code'])
        if 'data' in msg:
            event['data'] = msg['data']

        result = worker_module.worker(msg['continuation'], event)

        if result is None:
            result = dict(status='WORKER_CRASHED')

        if 'state' in result:
            result['continuation'] = result['state']
            del(result['state'])

        result['msgid']    = msg['msgid']
        result['workerid'] = msg['workerid']

        while True:
            status, reason, msg = http_client('POST', '/commit', result)
            if status < 500:
                break
            time.sleep(5)
else:
    log('argument({0}) is illegal'.format(sys.argv[1]))
