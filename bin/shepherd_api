#!/usr/bin/env python
import os
import re
import json
import time
import fcntl
import flask
import base64
import sqlite3
import pymysql
import hashlib
import functools

schema="""
create database if not exists shepherd;
use shepherd;

create table apps(
    appid     int unsigned primary key auto_increment,
    appkey    char(32)  not null,
    state     char(16)  not null,
    python    char(255),
    syspath   char(255),
    username  char(64),
    timestamp timestamp
) engine=innodb auto_increment=100000;

create table appnames(
    appname char(64) primary key,
    appid   int unsigned,
    foreign key(appid) references apps(appid)
) engine=innodb;

create table hosts(
    appid       int unsigned not null,
    ip          char(15)     not null,
    count_async int unsigned not null,
    count_sync  int unsigned not null,
    primary key(appid, ip)
) engine=innodb;

create table pools(
    appid int unsigned not null,
    pool  char(32)     not null,
    ip    char(15)     not null,
    primary key(appid, pool, ip)
) engine=innodb;

create table locks(
    sequence   bigint unsigned primary key auto_increment,
    lockname   char(64)        not null,
    appid      int unsigned    not null,
    workerid   bigint unsigned not null,
    unique(lockname, appid, workerid)
) engine=innodb;
create index lock1 on locks(appid, workerid, lockname);

create table workers(
    workerid     bigint unsigned primary key auto_increment,
    appid        int unsigned not null,
    state        char(16)     not null,
    status       longblob,
    continuation longblob,
    session      int unsigned not null default 0,
    created      timestamp default current_timestamp,
    timestamp    timestamp,
    foreign key(appid) references apps(appid)
) engine=innodb;

create table workernames(
    appid      int unsigned not null,
    workername char(64)     not null,
    workerid   bigint unsigned,
    primary key(appid, workername),
    foreign key(workerid) references workers(workerid)
) engine=innodb;

create table messages(
    msgid          bigint unsigned primary key auto_increment,
    appid          int unsigned    not null,
    workerid       bigint unsigned not null,
    senderappid    int unsigned not null,
    senderworkerid bigint unsigned not null,
    pool           char(32) not null default 'default',
    state          char(16) not null,
    lock_ip        char(15),
    priority       tinyint unsigned not null default 128,
    code           char(64) not null,
    data           longblob,
    timestamp      timestamp default current_timestamp
) engine=innodb;

create index msg1 on messages(timestamp, state, lock_ip, appid, pool);
create index msg2 on messages(appid, workerid, msgid);

create table config(
    name  varchar(256) primary key,
    value varchar(256)
) engine=innodb;

create table agentkeys(
    ip  char(15) primary key,
    agentkey char(32)
) engine=innodb;

insert into apps values
    (100001, 'testkey1', 'active','/tmp/abcd/bin/python', null,             null,       null),
    (100002, 'testkey2', 'active','/tmp/abcd/bin/python', null,             'testapp2', null),
    (100003, 'testkey3', 'active','/usr/bin/python',      '/tmp/sheeptest',  null,      null),
    (100004, 'testkey4', 'active','/usr/bin/python',      '/tmp/sheeptest', 'testapp4', null);

insert into appnames values
    ('testapp1',   100001),
    ('testapp2',   100002),
    ('testapp3',   100003),
    ('testapp4',   100004);

insert into hosts values
    (100001, '172.21.205.32', 100, 0),
    (100002, '172.21.205.32', 100, 0),
    (100003, '172.21.205.32', 100, 0),
    (100004, '172.21.205.32', 100, 0);

insert into pools values
    (100001, 'centralbox', '172.21.205.32'),
    (100002, 'centralbox', '172.21.205.32'),
    (100003, 'centralbox', '172.21.205.32'),
    (100004, 'centralbox', '172.21.205.32');

insert into agentkeys values
    ('172.21.205.32', 'somekey');
"""


application = flask.Flask(__name__)

db_conn = None
db_cursor = None

def getenv(key, default=None):
    value = flask.request.environ.get(key)
    if not value:
        value =  os.environ.get(key)
    if not value:
        value = default
    return value

class CustomException():
    def __init__(self, status, response):
        self.status = status
        self.response = response


def throw(status, response):
    raise CustomException(status, response)


def json_response(status, obj=None):
    obj, status = (status, obj) if obj else (status, 200)

    return flask.Response(json.dumps(obj,
                                     default=lambda o: str(o),
                                     indent=4,
                                     sort_keys=True),
                          status,
                          mimetype='application/json')


def html_table_response(table):
    return flask.Response(
        '<table align="center" border="1">{0}</table>'.format(table),
        200, mimetype='text/html')
   

def transaction(*args, **kwargs):
    def fun(f):
        @application.route(*args, **kwargs)
        @functools.wraps(f)
        def f1(*args, **kwargs):
            global db_conn
            global db_cursor

            msec = time.time() * 1000

            if not db_conn:
                db_conn = pymysql.connect(getenv('MYSQL_HOST'),
                                          getenv('MYSQL_USER'),
                                          getenv('MYSQL_PASSWORD', ''),
                                          'shepherd')
            db_cursor = db_conn.cursor(pymysql.cursors.DictCursor)

            try:
                response = f(*args, **kwargs)
                db_conn.commit()
                status = 200
            except CustomException as e:
                db_conn.rollback()
                status = e.status
                response = e.response

            db_cursor.close()
            return json_response(response, status)
        return f1
    return fun


def query(sql, params=None):
    db_cursor.execute(sql, params)
    return db_cursor.fetchall()


def validate_request(appname=None):
    req = json.loads(flask.request.data)
    appkey = flask.request.headers.get('X-SHEPHERD-APPKEY')
    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)

    if appname:
        rows = query("select appid from appnames where appname=%s", (appname))
        if 1 != len(rows):
            throw(404, 'INVALID_APPNAME')

        appid = rows[0]['appid']
    else:
        appname = flask.request.headers.get('X-SHEPHERD-APPNAME')
        appid   = flask.request.headers.get('X-SHEPHERD-APPID')

    if not appkey:
        throw(401, 'APPKEY_MISSING')

    if not (appname or appid):
        throw(400, 'BOTH_APPNAME_APPID_MISSING')

    if not appid:
        appid = query("select appid from appnames where appname=%s",
                      (appname))[0]['appid']

    query("update apps set appid=appid where appid=appid")
    row = query("select appkey, state from apps where appid=%s", (appid))

    if 1 != len(row):
        throw(400, 'INVALID_APP')

    if 'X-SHEPHERD-AGENTKEY' in flask.request.headers:
        if appkey != hashlib.md5(agentip+row[0]['appkey']).hexdigest():
            throw(403, 'KEY_MISMATCH')
    else:
        if appkey != row[0]['appkey']:
            throw(403, 'KEY_MISMATCH')

    if 'active' != row[0]['state']:
        throw(404, 'INACTIVE_APP')

    if not req:
        req = dict()

    req.update(dict(appid=appid, agentip=agentip))

    return req


@transaction('/config', methods=['GET'])
def config_get():
    result = dict([(r['name'], r['value'])
                  for r in query("select * from config")])

    result['agentip'] = flask.request.headers.get('X-Real-IP',
                                                  flask.request.remote_addr)
    return result


@transaction('/pending', methods=['GET'])
def pending_get():
    apps = dict([(r['appid'], r)
                 for r in  query("select * from apps where state='active'")])

    counts = dict()
    for appid in apps.keys():
        counts[appid] = dict([(h['ip'], h['count_async']) for h in query("""
            select ip, count_async from hosts where appid=%s""", (appid))])

    msgs = query("""select appid, pool, count(*) as count
                    from messages
                    where timestamp < now() and state='head' and lock_ip is null
                    group by appid, pool""")

    allocation = dict()
    for m in msgs:
        if m['appid'] not in apps:
            continue

        if 'default' == m['pool']:
            ip_list = [r['ip'] for r in query("""select distinct ip
                from hosts where appid=%s""", (m['appid']))]
        else:
            ip_list = [r['ip'] for r in
                       query("""select distinct ip from pools
                        where appid=%s and pool=%s""", (m['appid'], m['pool']))]

        while m['count'] > 0:
            start_count = m['count']
            for ip in ip_list:
                allocation.setdefault(ip, dict()).setdefault(m['appid'], 0)

                if allocation[ip][m['appid']] < counts[m['appid']][ip]:
                    allocation[ip][m['appid']] += 1
                    m['count'] -= 1
                    if 0 == m['count']:
                        break
            if m['count'] == start_count:
                break

    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)
    agentkey = flask.request.headers.get('X-SHEPHERD-AGENTKEY')

    rec = query("select agentkey from agentkeys where ip=%s", (agentip))
    if (1 != len(rec)) or (agentkey != rec[0]['agentkey']):
        for k, v in apps.iteritems():
            del(v['appkey'])
    else:
        for k, v in apps.iteritems():
            v['appkey'] = hashlib.md5(agentip+v['appkey']).hexdigest()
    
    return dict(applications=apps, allocation=allocation)


def insert_worker(appid, continuation, pool, priority):
    query("""insert into workers set appid=%s, state='active',
             continuation=%s, status='null'""", (appid, continuation))
    workerid = query("select last_insert_id() as workerid")[0]['workerid']
    query("""insert into messages
             set workerid=%s, appid=%s, senderworkerid=%s, senderappid=%s,
                 pool=%s, state='head',
                 priority=%s, code='init'
          """, (workerid, appid, workerid, appid, pool, priority))

    return workerid


def create_worker(req):
    appid    = req['appid']
    pool     = req.get('pool', 'default')
    priority = req.get('priority', 128)

    if 'workflow' in req:
        req['data'] = dict(workflow=req['workflow'], input=req['data'])

    return insert_worker(appid,
                         json.dumps(req['data'], indent=4, sort_keys=True),
                         pool,
                         priority)


@transaction('/workers/<appname>', methods=['POST'])
def worker_post(appname):
    return dict(workerid=create_worker(validate_request(appname)))


@transaction('/workers/<appname>/<workername>', methods=['PUT'])
def worker_put(appname, workername):
    req = validate_request(appname)

    query("insert into workernames set appid=%s, workername=%s,workerid=%s",
          (req['appid'], workername, create_worker(req)))

    return dict(workername=workername)


@transaction('/workers/<appname>/<workerid>', methods=['GET'])
def get_worker_status(appname, workerid):
    req = validate_request(appname)

    if not workerid.isdigit():
        workerid = query("""select workerid from workernames
                            where appid=%s and workername=%s
                         """, (req['appid'], workerid))[0]['workerid']

    rows = query("select status from workers where workerid=%s and appid=%s",
                 (workerid, req['appid']))

    if 1 != len(rows):
        throw(404, 'WORKER_NOT_FOUND')

    return json.loads(rows[0]['status'])


def mark_head(appid, workerid):
    msgid = query("""select msgid from messages
                     where appid=%s and workerid=%s
                     order by msgid limit 1
                  """,
                  (appid, workerid))
    if len(msgid) > 0:
        query("""update messages set state='head'
                 where msgid=%s""", (msgid[0]['msgid']))


@transaction('/messages/<appname>/<workerid>', methods=['POST'])
def add_msg(appname, workerid):
    req      = validate_request()
    pool     = req.get('pool', 'default')
    priority = req.get('priority', 128)
    data     = req.get('data', None)
    delay    = req.get('delay', 0)

    if data:
        data = json.dumps(data, indent=4, sort_keys=True)

    rows = query("select appid from appnames where appname=%s", (appname))
    if 1 != len(rows):
        throw(404, 'INVALID_APPNAME')
    appid = rows[0]['appid']

    if not workerid.isdigit():
        rows = query("""select workerid from workernames
                        where appid=%s and workername=%s
                     """, (appid, workerid))
        if 1 != len(rows):
            throw(404, 'INVALID_WORKERNAME')

        workerid = rows[0]['workerid']

    rows = query("""select appid from workers
                    where workerid=%s and state != 'done'
                 """, (workerid))
    if 1 != len(rows):
        throw(404, 'INVALID_WORKER_STATE')

    query("""insert into messages
             set workerid=%s, appid=%s,
                 senderworkerid=%s, senderappid=%s,
                 pool=%s, state='queued',
                 priority=%s, code=%s, data=%s,
                 timestamp=now()+interval %s second
          """,
          (workerid, appid, 0, req['appid'],
           pool, priority, req['code'], data, delay))

    mark_head(appid, workerid)

    return "OK"

@transaction('/commit', methods=['POST'])
def commit():
    req = validate_request()

    pool = query("select pool from messages where msgid=%s", (req['msgid']))
    query("delete from messages where msgid=%s", (req['msgid']))

    pool = req.get('pool', pool[0]['pool'])

    if 'continuation' not in req:
        if 'exception' in req:
            workflow_status = req['exception']
            workflow_state  = 'exception'
        elif 'status' in req:
            workflow_status = req['status']
            workflow_state  = 'done'
        else:
            workflow_status = 'unknown'
            workflow_state  = 'exception'

        query("""delete from messages where appid=%s and workerid=%s""",
              (req['appid'], req['workerid']))
        query("""update workers set status=%s, continuation=null, state=%s
                 where workerid=%s and appid=%s
              """, (json.dumps(workflow_status, indent=4, sort_keys=True),
                    workflow_state,
                    req['workerid'],
                    req['appid']))
        return "OK"

    def insert_message(appid, workerid, pool, code, data=None):
        if data:
            data = json.dumps(data, indent=4, sort_keys=True)

        query("""insert into messages
                 set workerid=%s, appid=%s,
                     senderworkerid=%s, senderappid=%s,
                     pool=%s, state='queued', code=%s, data=%s
              """, (workerid, appid, req['workerid'], req['appid'],
                    pool, code, data))

    def get_lock_holder(lockname):
        row = query("""select appid, workerid from locks
                       where lockname=%s order by sequence limit 1
                    """, (lockname))
        if len(row) < 1:
            return None, None
        else:
            return row[0]['appid'], row[0]['workerid']

    if 'lock' in req:
        for lockname in set(req['lock']):
            query("insert into locks set lockname=%s, appid=%s, workerid=%s",
                 (lockname, req['appid'], req['workerid']))

        counter = 0
        for lockname in set(req['lock']):
            row = query("""select workerid from locks
                           where lockname=%s order by sequence limit 1
                        """, (lockname))

            if row[0]['workerid'] == req['workerid']:
                counter += 1

        if len(set(req['lock'])) == counter:
            insert_message(req['appid'], req['workerid'], pool, 'locked')

    if 'unlock' in req:
        for lockname in set(req['unlock']):
            query("""delete from locks
                     where lockname=%s and appid=%s and workerid=%s
                  """,
                  (lockname, req['appid'], req['workerid']))

        to_be_unlocked = set()
        for lockname in set(req['unlock']):
            other_appid, other_workerid = get_lock_holder(lockname)

            if other_workerid:
                locks = query("""select lockname from locks
                                 where appid=%s and workerid=%s
                              """, (other_appid, other_workerid))

                counter = 0
                for l in locks:
                    tmp_appid, tmp_workerid = get_lock_holder(l['lockname'])
                    if other_workerid == tmp_workerid:
                        counter += 1

                if len(locks) == counter:
                    to_be_unlocked.add((other_appid, other_workerid))

        for app_worker in to_be_unlocked:
            insert_message(app_worker[0], app_worker[1], 'default', 'locked')
            mark_head(app_worker[0], app_worker[1])

    if 'message' in req:
        for msg in req['message']:
            if 'appid' not in msg:
                msg['appid'] = query("""select appid from appnames
                    where appname=%s""", (msg['appname']))[0]['appid']

            if 'workerid' not in msg:
                msg['workerid'] = query("""select workerid
                    from workernames where appid=%s and workername=%s""",
                    (msg['appid'], msg['workername']))[0]['workerid']

            insert_message(msg['appid'], msg['workerid'],
                msg.get('pool', 'default'),
                msg['code'],
                msg.get('data', None))
            mark_head(msg['appid'], msg['workerid'])

    if 'alarm' in req:
        if int(req['alarm']) < 1:
            req['alarm'] = 0

        query("""delete from messages
                 where appid=%s and workerid=%s and code='alarm'
              """, (req['appid'], req['workerid']))

        query("""insert into messages
                 set workerid=%s, appid=%s, senderworkerid=%s, senderappid=%s,
                     pool=%s, state='queued',
                     code='alarm', timestamp=now()+interval %s second""",
              (req['workerid'], req['appid'], req['workerid'], req['appid'],
               pool, req['alarm']))

    mark_head(req['appid'], req['workerid'])

    query("update workers set status=%s, continuation=%s where workerid=%s",
          (json.dumps(req['status'], indent=4, sort_keys=True),
           json.dumps(req['continuation'], indent=4, sort_keys=True),
           req['workerid']))

    return "OK"

@transaction('/lockmessage', methods=['POST'])
def lockmessage_post():
    sql1 = """select msgid, workerid, code, data from messages
              where timestamp < now() and state='head' and
                    appid=%s and pool=%s and lock_ip is null
              order by priority limit 1
           """

    req = validate_request()
    appid = req['appid']

    hosts = dict([(r['ip'], r) for r in
                  query("select * from hosts where appid=%s", (appid))])

    pools = dict()
    for rec in query("select pool, ip from pools where appid=%s", (appid)):
        pools.setdefault(rec['pool'], list()).append(rec['ip'])

    pools['default'] = hosts.keys()

    for pool in sorted(pools.keys()):
        for ip in sorted(set(pools[pool])):
            rows = query(sql1, (req['appid'], pool))
            if len(rows) > 0:
                query("update messages set lock_ip=%s where msgid=%s",
                      (req['agentip'], rows[0]['msgid']))
                query("""update workers set session=session+1
                         where workerid=%s""", (rows[0]['workerid']))

                worker = query("""select continuation, session from workers
                               where workerid=%s""", (rows[0]['workerid']))[0]

                result = dict(msgid        = rows[0]['msgid'],
                              workerid     = rows[0]['workerid'],
                              session      = worker['session'],
                              continuation = json.loads(worker['continuation']),
                              code         = rows[0]['code'],
                              pool         = pool)

                if rows[0]['data']:
                    result['data'] = json.loads(rows[0]['data'])

                return result

    return "NOT_FOUND"

regex = re.compile('^\[(.+?) (\d+) (\d+) (\d{6}\.\d{6}\.\d{6}) (.+?)\] : ')

@application.route('/log/<logfile>/<size>', methods=['POST'])
def log_put(logfile, size):
    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)
    os.chdir(getenv('LOGDIR'))

    logfile = os.path.join(agentip, logfile)

    fd = None
    try:
        if not os.path.isdir(agentip):
            os.makedirs(agentip)

        fd = os.open(logfile, os.O_CREAT|os.O_WRONLY|os.O_APPEND)
        fcntl.flock(fd, fcntl.LOCK_EX|fcntl.LOCK_NB)

        if os.fstat(fd).st_size == int(size):
            os.write(fd, flask.request.data)

        result = dict(size=os.fstat(fd).st_size)
    finally:
        os.close(fd)

    conn = sqlite3.connect('index.db')
    conn.execute("""create table if not exists offsets(thread text,
        session integer, timestamp text, logfile text,
        begin integer, end integer, primary key(thread, session))""")
    conn.execute("create index if not exists timestamp on offsets(timestamp)")
    conn.execute("""create table if not exists files(logfile text,
        processed integer, primary key(logfile))""")
    processed = conn.execute("select processed from files where logfile=?",
                          (logfile,)).fetchone()
    if processed:
        processed = processed[0]
    else:
        processed = 0
        conn.execute("insert into files values(?, 0)", (logfile,))
        conn.commit()
    conn.close()

    with open(logfile, 'r') as file:
        file.seek(processed)
        boffsets = dict()
        eoffsets = dict()
        for line in file:
            m = regex.match(line)
            if m:
                key = (m.group(1), m.group(2))
                if key not in boffsets:
                    boffsets[key] = (m.group(4), processed)
                eoffsets[key] = processed + len(line)
            processed += len(line)

    conn = sqlite3.connect('index.db')
    conn.executemany("insert or ignore into offsets values(?,?,?,?,?,0)",
        [(k[0], k[1], v[0], logfile, v[1]) for k,v in boffsets.iteritems()])
    conn.executemany("update offsets set end=? where thread=? and session=?",
        [(v, k[0], k[1]) for k,v in eoffsets.iteritems()])
    conn.execute("update files set processed=? where logfile=?",
                 (processed, logfile))
    conn.commit()
    conn.close()

    return json_response(result)


@application.route('/logs', methods=['GET'])
@application.route('/logs/<thread>', methods=['GET'])
@application.route('/logs/<thread>/<session>', methods=['GET'])
def logs_get(thread=None, session=None):
    os.chdir(getenv('LOGDIR'))

    begin = flask.request.args.get('begin', '0')
    end   = flask.request.args.get('end',   '9')
    limit = flask.request.args.get('limit', 25)

    conn = sqlite3.connect('index.db')

    if (thread is None) and (session is None):
        result = conn.execute("""select thread, max(timestamp) from offsets
            where timestamp > ? and timestamp < ?
            group by thread order by timestamp desc
            limit ?""", (begin, end, limit)).fetchall()
        conn.close()
        response = html_table_response(''.join([
            '<tr><td><a href="{0}">{1}</a></td><td>{2}</tr>'.format(
                '/logs/{0}'.format(r[0]), r[0], r[1])
            for r in result]))
    elif session is None:
        result = conn.execute("""select session, timestamp from offsets
            where thread=? order by timestamp desc""", (thread,)).fetchall()
        conn.close()
        response = html_table_response(''.join([
            '<tr><td><a href="{0}">{1}</a></td><td>{2}</td></tr>'.format(
                '/logs/{0}/{1}'.format(thread, r[0]), r[0], r[1])
                    for r in result]))
    else:
        rows = conn.execute("""select session, logfile, begin, end
            from offsets where thread=?""", (thread,)).fetchall()
        conn.close()

        if 'all' != session:
            sset = set()
            for l in [r.split('-') for r in session.split(',')]:
                r = (l[0], l[1]) if (len(l) > 1) else (l[0], l[0])
                for n in range(int(r[0]), int(r[1])+1):
                    sset.add(n)
            sdict = dict([(r[0], (r[1], r[2], r[3]))
                         for r in rows if r[0] in sset])
        else:
            sdict = dict([(r[0], (r[1], r[2], r[3])) for r in rows])

        result = list()
        for s in sorted(sdict.keys()):
            logfile, begin, end = sdict[s]

            with open(logfile, 'r') as file:
                file.seek(begin)

                blobs  = dict()
                for line in file:
                    if begin > end:
                        break

                    m = regex.match(line)
                    if m and (thread == m.group(1)) and (str(s) == m.group(2)):
                        seq, timestamp, tag = m.group(3), m.group(4), m.group(5)
                        if 'BLOB' == tag:
                            hdr = '[{0} {1} {2} {3} {4}]'.format(m.group(1),
                                m.group(2), seq, timestamp, tag)
                            blobs[hashlib.md5(hdr).hexdigest()] = begin
                        else:
                            msg = line[len(m.group(0)):]
                            for m in re.findall('<\w{32}>', msg):
                                msg = msg.replace(m,
                                    '<a href="/blob/{0}/{1}">blob</a>'.format(
                                        logfile, blobs[m[1:33]]))

                            result.append((timestamp, tag, msg))
                    begin += len(line)

        response = html_table_response(''.join([
            '<tr class="{0}"><td>{1}</td><td>{2}</td></tr>'.format(
                r[1], r[0], r[2]) for r in result]))
    return response


@application.route('/blob/<ip>/<logfile>/<offset>', methods=['GET'])
def blob_get(ip, logfile, offset):
    os.chdir(getenv('LOGDIR'))

    with open(os.path.join(ip, logfile)) as file:
        file.seek(int(offset))

        line = file.readline()
        m = regex.match(line)
        if m:
            return flask.Response(base64.b64decode(line[len(m.group(0)):]),
                                  200, mimetype='text/plain')

    return flask.Response('NOT FOUND', 402, mimetype='text/plain')


if __name__ == '__main__':
    application.debug = True
    application.run(host='0.0.0.0', port=5000)
