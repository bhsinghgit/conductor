#!/usr/bin/env python
import os
import re
import json
import time
import fcntl
import flask
import sqlite3
import pymysql
import hashlib
import functools

application = flask.Flask(__name__)

db_conn = pymysql.connect('127.0.0.1', 'root', '', 'shepherd')
db_cursor = db_conn.cursor()


class CustomException():
    def __init__(self, status, response):
        self.status = status
        self.response = response


def throw(status, response):
    raise CustomException(status, response)


def transaction(*args, **kwargs):
    def fun(f):
        @application.route(*args, **kwargs)
        @functools.wraps(f)
        def f1(*args, **kwargs):
            global db_cursor
            msec = time.time() * 1000

            db_cursor.close()
            db_cursor = db_conn.cursor(pymysql.cursors.DictCursor)

            try:
                response = f(*args, **kwargs)
                db_conn.commit()
                status = 200
            except CustomException as e:
                db_conn.rollback()
                status = e.status
                response = e.response

            return flask.Response(json.dumps(response,
                                             default=lambda o: str(o),
                                             indent=4,
                                             sort_keys=True),
                                  status,
                                  mimetype='application/json')
        return f1
    return fun


def query(sql, params=None):
    db_cursor.execute(sql, params)
    return db_cursor.fetchall()


def validate_request(appname=None):
    req = json.loads(flask.request.data)
    appkey = flask.request.headers.get('X-SHEPHERD-APPKEY')
    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)

    if appname:
        rows = query("select appid from appnames where appname=%s", (appname))
        if 1 != len(rows):
            throw(404, 'INVALID_APPNAME')

        appid = rows[0]['appid']
    else:
        appname = flask.request.headers.get('X-SHEPHERD-APPNAME')
        appid   = flask.request.headers.get('X-SHEPHERD-APPID')

    if not appkey:
        throw(401, 'APPKEY_MISSING')

    if not (appname or appid):
        throw(400, 'BOTH_APPNAME_APPID_MISSING')

    if not appid:
        appid = query("select appid from appnames where appname=%s",
                      (appname))[0]['appid']

    query("update apps set appid=appid where appid=appid")
    row = query("select appkey, state from apps where appid=%s", (appid))

    if 1 != len(row):
        throw(400, 'INVALID_APP')

    if 'X-SHEPHERD-AGENTKEY' in flask.request.headers:
        if appkey != hashlib.md5(agentip+row[0]['appkey']).hexdigest():
            throw(403, 'KEY_MISMATCH')
    else:
        if appkey != row[0]['appkey']:
            throw(403, 'KEY_MISMATCH')

    if 'active' != row[0]['state']:
        throw(404, 'INACTIVE_APP')

    if not req:
        req = dict()

    req.update(dict(appid=appid, agentip=agentip))

    return req


@transaction('/config', methods=['GET'])
def config_get():
    return dict([(r['name'], r['value'])
                for r in query("select * from config")])


@transaction('/pending', methods=['GET'])
def pending_get():
    apps = dict([(r['appid'], r)
                 for r in  query("select * from apps where state='active'")])

    counts = dict()
    for appid in apps.keys():
        counts[appid] = dict([(h['ip'], h['count_async']) for h in query("""
            select ip, count_async from hosts where appid=%s""", (appid))])

    msgs = query("""select appid, pool, count(*) as count
                    from messages
                    where timestamp < now() and state='head' and lock_ip is null
                    group by appid, pool""")

    allocation = dict()
    for m in msgs:
        if m['appid'] not in apps:
            continue

        if 'default' == m['pool']:
            ip_list = [r['ip'] for r in query("""select distinct ip
                from hosts where appid=%s""", (m['appid']))]
        else:
            ip_list = [r['ip'] for r in
                       query("""select distinct ip from pools
                        where appid=%s and pool=%s""", (m['appid'], m['pool']))]

        while m['count'] > 0:
            start_count = m['count']
            for ip in ip_list:
                allocation.setdefault(ip, dict()).setdefault(m['appid'], 0)

                if allocation[ip][m['appid']] < counts[m['appid']][ip]:
                    allocation[ip][m['appid']] += 1
                    m['count'] -= 1
                    if 0 == m['count']:
                        break
            if m['count'] == start_count:
                break

    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)
    agentkey = flask.request.headers.get('X-SHEPHERD-AGENTKEY')

    rec = query("select agentkey from agentkeys where ip=%s", (agentip))
    if (1 != len(rec)) or (agentkey != rec[0]['agentkey']):
        for k, v in apps.iteritems():
            del(v['appkey'])
    else:
        for k, v in apps.iteritems():
            v['appkey'] = hashlib.md5(agentip+v['appkey']).hexdigest()
    
    return dict(applications=apps,
                allocation=allocation,
                agentip=agentip)


def insert_worker(appid, continuation, pool, priority):
    query("""insert into workers set appid=%s, state='active',
             continuation=%s, status='null'""", (appid, continuation))
    workerid = query("select last_insert_id() as workerid")[0]['workerid']
    query("""insert into messages
             set workerid=%s, appid=%s, senderworkerid=%s, senderappid=%s,
                 pool=%s, state='head',
                 priority=%s, code='init'
          """, (workerid, appid, workerid, appid, pool, priority))

    return workerid


def create_worker(req):
    appid    = req['appid']
    pool     = req.get('pool', 'default')
    priority = req.get('priority', 128)

    if 'workflow' in req:
        req['data'] = dict(workflow=req['workflow'], input=req['data'])

    return insert_worker(appid,
                         json.dumps(req['data'], indent=4, sort_keys=True),
                         pool,
                         priority)


@transaction('/workers/<appname>', methods=['POST'])
def worker_post(appname):
    return dict(workerid=create_worker(validate_request(appname)))


@transaction('/workers/<appname>/<workername>', methods=['PUT'])
def worker_put(appname, workername):
    req = validate_request(appname)

    query("insert into workernames set appid=%s, workername=%s,workerid=%s",
          (req['appid'], workername, create_worker(req)))

    return dict(workername=workername)


@transaction('/workers/<appname>/<workerid>', methods=['GET'])
def get_worker_status(appname, workerid):
    req = validate_request(appname)

    if not workerid.isdigit():
        workerid = query("""select workerid from workernames
                            where appid=%s and workername=%s
                         """, (req['appid'], workerid))[0]['workerid']

    rows = query("select status from workers where workerid=%s and appid=%s",
                 (workerid, req['appid']))

    if 1 != len(rows):
        throw(404, 'WORKER_NOT_FOUND')

    return json.loads(rows[0]['status'])


def mark_head(appid, workerid):
    msgid = query("""select msgid from messages
                     where appid=%s and workerid=%s
                     order by msgid limit 1
                  """,
                  (appid, workerid))
    if len(msgid) > 0:
        query("""update messages set state='head'
                 where msgid=%s""", (msgid[0]['msgid']))


@transaction('/messages/<appname>/<workerid>', methods=['POST'])
def add_msg(appname, workerid):
    req      = validate_request()
    pool     = req.get('pool', 'default')
    priority = req.get('priority', 128)
    data     = req.get('data', None)
    delay    = req.get('delay', 0)

    if data:
        data = json.dumps(data, indent=4, sort_keys=True)

    rows = query("select appid from appnames where appname=%s", (appname))
    if 1 != len(rows):
        throw(404, 'INVALID_APPNAME')
    appid = rows[0]['appid']

    if not workerid.isdigit():
        rows = query("""select workerid from workernames
                        where appid=%s and workername=%s
                     """, (appid, workerid))
        if 1 != len(rows):
            throw(404, 'INVALID_WORKERNAME')

        workerid = rows[0]['workerid']

    rows = query("""select appid from workers
                    where workerid=%s and state != 'done'
                 """, (workerid))
    if 1 != len(rows):
        throw(404, 'INVALID_WORKER_STATE')

    query("""insert into messages
             set workerid=%s, appid=%s,
                 senderworkerid=%s, senderappid=%s,
                 pool=%s, state='queued',
                 priority=%s, code=%s, data=%s,
                 timestamp=now()+interval %s second
          """,
          (workerid, appid, 0, req['appid'],
           pool, priority, req['code'], data, delay))

    mark_head(appid, workerid)

    return "OK"

@transaction('/commit', methods=['POST'])
def commit():
    req = validate_request()

    pool = query("select pool from messages where msgid=%s", (req['msgid']))
    query("delete from messages where msgid=%s", (req['msgid']))

    pool = req.get('pool', pool[0]['pool'])

    if 'continuation' not in req:
        if 'exception' in req:
            workflow_status = req['exception']
            workflow_state  = 'exception'
        elif 'status' in req:
            workflow_status = req['status']
            workflow_state  = 'done'
        else:
            workflow_status = 'unknown'
            workflow_state  = 'exception'

        query("""delete from messages where appid=%s and workerid=%s""",
              (req['appid'], req['workerid']))
        query("""update workers set status=%s, continuation=null, state=%s
                 where workerid=%s and appid=%s
              """, (json.dumps(workflow_status, indent=4, sort_keys=True),
                    workflow_state,
                    req['workerid'],
                    req['appid']))
        return "OK"

    def insert_message(appid, workerid, pool, code, data=None):
        if data:
            data = json.dumps(data, indent=4, sort_keys=True)

        query("""insert into messages
                 set workerid=%s, appid=%s,
                     senderworkerid=%s, senderappid=%s,
                     pool=%s, state='queued', code=%s, data=%s
              """, (workerid, appid, req['workerid'], req['appid'],
                    pool, code, data))

    def get_lock_holder(lockname):
        row = query("""select appid, workerid from locks
                       where lockname=%s order by sequence limit 1
                    """, (lockname))
        if len(row) < 1:
            return None, None
        else:
            return row[0]['appid'], row[0]['workerid']

    if 'lock' in req:
        for lockname in set(req['lock']):
            query("insert into locks set lockname=%s, appid=%s, workerid=%s",
                 (lockname, req['appid'], req['workerid']))

        counter = 0
        for lockname in set(req['lock']):
            row = query("""select workerid from locks
                           where lockname=%s order by sequence limit 1
                        """, (lockname))

            if row[0]['workerid'] == req['workerid']:
                counter += 1

        if len(set(req['lock'])) == counter:
            insert_message(req['appid'], req['workerid'], pool, 'locked')

    if 'unlock' in req:
        for lockname in set(req['unlock']):
            query("""delete from locks
                     where lockname=%s and appid=%s and workerid=%s
                  """,
                  (lockname, req['appid'], req['workerid']))

        to_be_unlocked = set()
        for lockname in set(req['unlock']):
            other_appid, other_workerid = get_lock_holder(lockname)

            if other_workerid:
                locks = query("""select lockname from locks
                                 where appid=%s and workerid=%s
                              """, (other_appid, other_workerid))

                counter = 0
                for l in locks:
                    tmp_appid, tmp_workerid = get_lock_holder(l['lockname'])
                    if other_workerid == tmp_workerid:
                        counter += 1

                if len(locks) == counter:
                    to_be_unlocked.add((other_appid, other_workerid))

        for app_worker in to_be_unlocked:
            insert_message(app_worker[0], app_worker[1], 'default', 'locked')
            mark_head(app_worker[0], app_worker[1])

    if 'message' in req:
        for msg in req['message']:
            if 'appid' not in msg:
                msg['appid'] = query("""select appid from appnames
                    where appname=%s""", (msg['appname']))[0]['appid']

            if 'workerid' not in msg:
                msg['workerid'] = query("""select workerid
                    from workernames where appid=%s and workername=%s""",
                    (msg['appid'], msg['workername']))[0]['workerid']

            insert_message(msg['appid'], msg['workerid'],
                msg.get('pool', 'default'),
                msg['code'],
                msg.get('data', None))
            mark_head(msg['appid'], msg['workerid'])

    if 'alarm' in req:
        if int(req['alarm']) < 1:
            req['alarm'] = 0

        query("""delete from messages
                 where appid=%s and workerid=%s and code='alarm'
              """, (req['appid'], req['workerid']))

        query("""insert into messages
                 set workerid=%s, appid=%s, senderworkerid=%s, senderappid=%s,
                     pool=%s, state='queued',
                     code='alarm', timestamp=now()+interval %s second""",
              (req['workerid'], req['appid'], req['workerid'], req['appid'],
               pool, req['alarm']))

    mark_head(req['appid'], req['workerid'])

    query("update workers set status=%s, continuation=%s where workerid=%s",
          (json.dumps(req['status'], indent=4, sort_keys=True),
           json.dumps(req['continuation'], indent=4, sort_keys=True),
           req['workerid']))

    return "OK"

@transaction('/lockmessage', methods=['POST'])
def lockmessage_post():
    sql1 = """select msgid, workerid, code, data from messages
              where timestamp < now() and state='head' and
                    appid=%s and pool=%s and lock_ip is null
              order by priority limit 1
           """

    req = validate_request()
    appid = req['appid']

    hosts = dict([(r['ip'], r) for r in
                  query("select * from hosts where appid=%s", (appid))])

    pools = dict()
    for rec in query("select pool, ip from pools where appid=%s", (appid)):
        pools.setdefault(rec['pool'], list()).append(rec['ip'])

    pools['default'] = hosts.keys()

    for pool in sorted(pools.keys()):
        for ip in sorted(set(pools[pool])):
            rows = query(sql1, (req['appid'], pool))
            if len(rows) > 0:
                query("update messages set lock_ip=%s where msgid=%s",
                      (req['agentip'], rows[0]['msgid']))
                query("""update workers set session=session+1
                         where workerid=%s""", (rows[0]['workerid']))

                worker = query("""select continuation, session from workers
                               where workerid=%s""", (rows[0]['workerid']))[0]

                result = dict(msgid        = rows[0]['msgid'],
                              workerid     = rows[0]['workerid'],
                              session      = worker['session'],
                              continuation = json.loads(worker['continuation']),
                              code         = rows[0]['code'],
                              pool         = pool)

                if rows[0]['data']:
                    result['data'] = json.loads(rows[0]['data'])

                return result

    return "NOT_FOUND"

LOGHOME = '/tmp/shepherd'
HEADER = re.compile('^\[(.+) (\d+) (\d+) (\d+) (\d{6}\.\d{6}\.\d{6}) (.+)\] : ')
@transaction('/log/<logfile>/<size>', methods=['POST'])
def log_put(logfile, size):
    agentip = flask.request.headers.get('X-Real-IP', flask.request.remote_addr)

    agentdir = os.path.join(LOGHOME, 'logs', agentip)
    if not os.path.isdir(agentdir):
        os.makedirs(agentdir)

    fd = None
    logfile = os.path.join(agentdir, logfile)
    try:
        fd = os.open(logfile, os.O_CREAT|os.O_WRONLY|os.O_APPEND)
        fcntl.flock(fd, fcntl.LOCK_EX|fcntl.LOCK_NB)
    except:
        os.close(fd)
        throw(400, 'FILE LOCKED')

    if os.fstat(fd).st_size == int(size):
        os.write(fd, json.loads(flask.request.data))

    result = dict(size=os.fstat(fd).st_size)
    os.close(fd)

    conn = sqlite3.connect(os.path.join(LOGHOME, 'index.db'))
    conn.execute("""create table if not exists offsets(
        thread text, session integer, offset integer,
        logfile text, primary key(thread, session))""")
    conn.execute("""create table if not exists files(
        logfile text, offset integer, primary key(logfile))""")
    offset = conn.execute("select offset from files where logfile=?",
                          [logfile]).fetchone()
    offset = offset[0] if offset else 0
    conn.execute("insert or ignore into files values(?, ?)", (logfile, offset))
    conn.commit()
    conn.close()

    file = open(logfile, 'r')
    file.seek(offset)
    index_dict = dict()
    for line in file:
        m = HEADER.match(line)
        if m:
            key = (m.group(1), m.group(2))
            if key not in index_dict:
                index_dict[key] = offset
        offset += len(line)
    file.close()

    index_list = list()
    for k, v in index_dict.iteritems():
        index_list.append((k[0], k[1], v, logfile))

    conn = sqlite3.connect(os.path.join(LOGHOME, 'index.db'))
    conn.executemany("insert or ignore into offsets values(?,?,?,?)",
        index_list)
    conn.execute("update files set offset=? where logfile=?", (offset, logfile))
    conn.commit()
    conn.close()

    return result


@transaction('/log/threads', methods=['GET'])
def threads_get():
    conn = sqlite3.connect(os.path.join(LOGHOME, 'index.db'))
    result = conn.execute("select distinct thread from offsets").fetchall()
    conn.close()
    return dict(count=len(result), threads=[r[0] for r in result])


@transaction('/log/thread/<thread>', methods=['GET'])
def thread_get(thread):
    conn = sqlite3.connect(os.path.join(LOGHOME, 'index.db'))
    result = conn.execute("""select session, offset, logfile from offsets
                             where thread=?""", (thread,)).fetchall()
    conn.close()
    return dict(thread=thread,
                count=len(result),
                sessions=dict([(r[0], dict(offset=r[1],
                                           logfile=r[2])) for r in result]))


@transaction('/log/msgs/<thread>/<session>', methods=['GET'])
def session_get(thread, session):
    conn = sqlite3.connect(os.path.join(LOGHOME, 'index.db'))
    logfile, offset = conn.execute("""select logfile, offset from offsets
                                      where thread=? and session=?
                                   """, (thread, session)).fetchone()
    conn.close()

    file = open(logfile, 'r')
    file.seek(offset)

    result = list()
    tags = dict()
    for line in file:
        m = HEADER.match(line)
        if m and (thread == m.group(1)) and (session == m.group(2)):
            tags.setdefault(m.group(6), 0)
            tags[m.group(6)] += 1
            result.append(line)

    return dict(count=tags, logs=result)

if __name__ == '__main__':
    application.debug = True
    application.run(host='0.0.0.0', port=5000)
